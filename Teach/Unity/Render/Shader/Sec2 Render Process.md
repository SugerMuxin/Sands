![[header.png]]
### 2.1 渲染流程
###### 渲染流程中的几个阶段
>1.应用阶段：这个阶段的任务是准备好渲染所需要的数据，例如摄像机的位置，视椎体，场景中包含了哪些模型，使用了哪些光源等；其次为了提高渲染性能，往往还需要做一个粗粒度剔除的工作，把那些看不见的物体剔除，这样就不需要移交给下一个阶段处理了
>
>2.几何阶段：几何阶段用于处理所有和我们要绘制的几何相关的事情。几何阶段负责和每个图元打交道，进行逐定点、逐多边形的操作。
>
>3.光栅化阶段：这个阶段会使用上个阶段传递过来的数据来产生屏幕上的像素，并渲染出最终的图像。这一阶段也是在GPU上运行。光栅化的主要任务是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。它需要对上一个阶段得到的定点数据进行差值，然后再进行逐像素的处理。


### 2.2 CPU 和 GPU之间的通信
###### 应用阶段的几个任务：
>1. 把数据加载到显存中（DHH => RAM => VRAM）(顶点心底，纹理坐标，法线方向，顶点颜色)
>
>2. 设置渲染状态：渲染状态指的是，这些状态定义了场景中的网格是怎样被渲染的。（例如使用了哪个顶点着色器、哪个片元着色器、光源属性、材质等）。
> 
>3. 调用DrawCall : 资源准备就绪，通知GPU根据渲染状态开始渲染

### 2.3GPU流水线
几何阶段和光栅化阶段都能再进行细分成多个流水线，以提高渲染效率。


![[shader_2.7.png]]
(tip: 颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权.)

>1.顶点着色器：在定点着色器中，我们可以改变顶点的位置，这在顶点动画中是非常有用的。我们可以通过改变顶点的位置来模拟水面和布料等。一个最基本的顶点着色器必须完成的一个工作是，把顶点坐标从<span style="color: pink;">模型空间转换到其次裁剪空间</span>。
>![[shader_2.8.png]]
>
>2.Culling ：裁剪掉不再摄像机的视野之外的物体。完全在视野之外的直接舍弃，完全在视野内的图元直接交给下一个阶段，而只有一部分在视野之内的则需要裁剪图元.
>![[shader_2.9.png]]
>3.屏幕映射： 屏幕映射的任务是把每个图元的x,y坐标转换到屏幕坐标，这一步还会保存一个Z值，和屏幕坐标系一起构成了一个窗口坐标系。
>
>👁<span style="color: yellow;">上面的步骤得到的结果是：屏幕坐标系下的顶点位置以及和它们相关的额外信息，如深度值Z，法线方向，视角方向等</span>
><span style="color:yellow;"></span>
>4. 三角形设置：这一步开始就进入了光栅化阶段。这个阶段会计算光栅化一个三角形的网格所需的信息。因为要想知道三角形对像素的覆盖情况，就必须知道每条边上的像素坐标。
>
>5. 三角形遍历：这个阶段会检查每个像素是否会被一个三角形网络所覆盖。如果被覆盖的话，就会生成一个片元（fragment）。这样找到每个像素被三角形覆盖的过程就叫做三角形遍历，这个阶段也被称为 <span style="color:pink; font-weight:bold">扫描变换</span>. 这一步得到的结果是输出一个片元序列。需要注意的是一个片元并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算没个像素最终的颜色。这些状态包括但不限于它的屏幕坐标、深度信息以及其他从集合阶段输出的顶点信息，例如法线、纹理坐标等.
>![[shader_2.12.png]]
>7. 片元着色器：也被称为像素着色器，但是片元着色器更准确，因为这一步的数据并不是一个真正意义上的像素。这一阶段可以完成很多重要的渲染技术，其中最重要的一个就是纹理采样。为了在片元着色器中进行纹理采样，我们通常会在定点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网络的三个顶点对应的纹理坐标进行差值后，就可以得到其覆盖的片元坐标纹理了。
>8. 逐片元操作：这一阶段被称为<span style="color:pink; font-weight:bold">输出合并阶段</span> ，这一步操作是高度可配置的，我们可以设置每一步操作的细节。这一阶段有几个主要任务
>   > (1)决定每个片元的可见性，这涉及了很多测试工作，如深度测试，模板测试
>   > (2)如果一个片元通过了所有测试，就需要把这个片元的颜色值和颜色缓冲区中的颜色进行混合
   ![[shader_2.14.png]]
>👁<span style="color: yellow;">模板测试和深度测试都有对应的缓冲区，分别为模板缓冲区和深度缓冲区</span>
><span style="color:pink; font-weight:bold">混合（Blend）</span>是针对透明物体的，不透明的物体可以关闭混合来优化性能
>💡<span style="color: yellow;">上述给出的测试顺序并不是唯一的，Early-Z技术，透明度测试</span>
>
>到这里渲染已经结束了。值得一提的是为了避免我们看到正在进行光栅化的图元，GPU使用了<span style="color:pink; font-weight:bold">双重缓冲</span>的策略。这意味着对场景的渲染都是在幕后进行的，即<span style="color:pink; font-weight:bold">后置缓冲</span>，一旦场景已经被渲染到后置缓冲，GPU就会交换后置缓冲和<span style="color:pink; font-weight:bold">前置缓冲</span>中的内容。由此保证我们看到的图像总是连续的。


### 2.4 一些记录点

##### HLSL,GLSL,CG分别是什么？

##### 什么是DrawCall？
Drawcall通常用于描述GPU在绘制图形时执行的单个请求。在图形编程中，绘制调用是将图形数据发送到GPU再渲染到屏幕上的一个过程。
###### 💡为什么Drawcall数量会影响到性能？
>1.CPU Overhead ：每个 Draw Call 都需要 CPU 在渲染管道中进行一系列的准备工作，比如设置渲染状态、传递顶点和纹理数据等。当 Draw Call 的数量很大时，这些 CPU 操作的开销将成为性能的一个瓶颈。
>
>2.GPU Overhead：GPU 在处理 Draw Call 时也需要开销，包括切换渲染状态、执行顶点和片元着色器等操作。当 Draw Call 的数量增加时，GPU 的工作负担也会增加，可能导致性能下降。
>
>3.通信开销：在一些情况下，由于 Draw Calls 的增加，需要在 CPU 和 GPU 之间频繁传输数据，这会引起额外的通信开销。例如，每个 Draw Call 都需要传输顶点数据、纹理数据等，这些数据传输的成本会随着 Draw Calls 的增加而增大。
>
>4.状态切换：Draw Calls 中可能涉及到渲染状态的切换，比如材质、着色器等的切换。频繁的状态切换会导致 GPU 在处理时需要进行额外的工作，从而影响性能。

```
命令缓冲区：命令缓冲区是一个命令队列，用来存储CPU发送给GPU的命令，当GPU完成上一个渲染命令时再来缓冲区来拿下一个渲染命令，从而达到流水线的渲染效果。命令缓冲区的命令有很多种，而Drawcall只是其中一种，其他的命令还有改变渲染状态（例如改变使用的着色器，使用不同的纹理）等。
```
###### 💡如何减少Drawcall？

>1. Batching 将多个对象合并成一个Drawcall，可以事先对静态对象(比如场景中不动的物体)进行网格。在游戏开发中，应该尽量避免使用大量很小的网格。同时避免过多的使用不同的材质。


